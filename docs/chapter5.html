<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title></title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>




<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Report</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="abstract.html">Abstract</a>
</li>
<li>
  <a href="exec-sum.html">Executive Summary</a>
</li>
<li>
  <a href="chapter1.html">1 - Introduction</a>
</li>
<li>
  <a href="chapter2.html">2 - Overview</a>
</li>
<li>
  <a href="chapter3.html">3 - Lower level tools</a>
</li>
<li>
  <a href="chapter4.html">4 - Designing interactr</a>
</li>
<li>
  <a href="chapter5.html">5 - Discussion</a>
</li>
<li>
  <a href="conclusion.html">Conclusion</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">




</div>


<p><br></p>
<div id="discussion" class="section level1">
<h1><span class="header-section-number">5</span> Discussion</h1>
<p>The <code>interactr</code> package provides a way of generating simple interactive R plots that can be viewed in a web browser. It is advantageous in the sense that we can easily define and customise interactions with flexibility. It can also achieve unidirectional linking between a variety of plots.</p>
<div id="limitations" class="section level2">
<h2><span class="header-section-number">5.1</span> Limitations</h2>
<p>Firstly, there are limitations that arise from using the gridSVG and DOM packages. With gridSVG, one major limitation is that only grid objects can be converted into SVG. This limits us to plots that must be drawn in R before being sent to the browser. A further limitation is that gridSVG is relatively slow when we try to convert a plot made up of many elements. To note, work is proceeding to make gridSVG faster.</p>
<p>As <code>interactr</code> is mainly built upon the <code>DOM</code> package, many of its limitations highlighted in Chapter 3 are carried forward. This includes the shareability and accessibility of these plots, where they are generated for a single user in a single session only. Furthermore, because the <code>DOM</code> package is still under development, it cannot be used for production purposes yet. Just as how shiny applications would require a shiny server to be hosted on the web, DOM would require something similar to allow for shareability and accessibility. This has not been done before, but may be experimented with in the future. Furthermore, because the underlying system consists of requests being sent between R and the web browser, this can be relatively slower when compared to plots that are driven fully by JavaScript.</p>
<p>There are further limitations within the package. The user must call <code>listElements</code> before sending the plot to the browser as it prints the plot and a correct list of elements that make up the plot. This is crucial for plotting systems that do not have a consistent naming scheme. If we reprint the plot, the tags will constantly change which may cause a mismatch between element matching between the plot on the web and the plot in R. Another problem with using <code>listElements</code> is that the user will need to deduce which element is on the plot as the naming for these objects in <code>grid</code> may not be clear. If it is a plot that is made directly from grid where the user has named everything clearly, then this is not a problem.</p>
<p><em>a simple example of naming grid objects that can be easily recovered</em></p>
<p><em>in comparison a ggplot that doesn’t have a clear naming scheme</em></p>
<p>However, if it is based upon a defined plotting system without a consistent naming scheme like ggplot2, then there is a need for deducing which elements correspond to which part of the plot.</p>
<p>Another limitation is the number of interactions that can be attached. So far, the examples expressed in Chapter 4.3 require a single element to be controlled. We can attach many interactions and events to a single element at a time, but not many elements to many different interactions at once. There is a need for a more flexible system when dealing with multiple interactions for achieving more complex interactions. Furthermore, only one kind of interaction can be expressed for a single event. This means that the function created by the user must be fully defined in a single function rather than multiple functions. For example, if a hover requires both adding a tooltip and to turn the element red, then this would need to be written as a single function as we can only attach one to each event.</p>
<p>Code must also be written in a certain order to work. Plots in R must be drawn to a graphics device before being sent to the browser, while a new web page must be set up before we can start adding elements and interactions to the page. In cases of dealing with multiple plots, one of the disadvantages is that we lose information about the previous plot in R. This means that the user is required to identify what kind of information they need to extract before they move onto the next plot. This is demonstrated in the example of linking box plot to other plots together - before the user can move onto the scatter plot, the range of the box and viewports were stored in order to be used in the defined function. This means that we cannot jump back and forth between plots. A possible solution to this is to store the information about each plot that is sent to the web browser that can be retrievable by the user if needed.</p>
<p><em>TODO: incorporate these</em> - WARNING from Paul about DOM: &gt; “DOM does nothing to help with synchronising cascades of updates (OR infinite loops of updates)”</p>
<ul>
<li>requires that units that are converted to ‘native’ via grid should represent the data. (for ggplot2, this doesn’t hold and requires a different conversion scale. In cases like this, there should be an alternative based upon where it gets data from: use <code>ggplot_build()</code>)</li>
<li>assumes no missing values and that plots generated via gridSVG should be in the order of the data frame. (ie point order should match with indices of the df.) In cases where data taken in is rearranged and sorted (like iNZightPlots), this causes the ‘indexes’ of the points to differ to the original dataframe.</li>
<li>assumes that most grid objects represent a single object in SVG (which sometimes is not the case - see iNZightPlot boxplot version)</li>
</ul>
</div>
<div id="comparison-to-existing-tools" class="section level2">
<h2><span class="header-section-number">5.2</span> Comparison to existing tools</h2>
<p>In most of the existing tools discussed in Chapter 2, they all rely on a JavaScript library to render their plots. These are not R plots. <code>interactr</code>‘s main selling point is the ability to replicate plots or objects drawn in R and to easily achieve on-plot and off-plot interactivity. <code>shiny</code> can do this but you cannot easily attach specific interactions as the plot is rendered as a png. Furthermore, many of these existing tools rely on the <code>shiny</code> framework. One of the major disadvantages that <code>shiny</code> possesses is a tendency to recompute and redraw entire plots whenever an input changes. In <code>interactr</code>, only part of the plot that the user specifically targets is modified, and more on-plot interactions can be achieved. It provides a possible way of linking different types of plots together, whereas existing tools, specifically crosstalk, have focused on linked brushing between ’row-as-observations’ data. To put in perspective, the simple example of linking box plots to other kinds of plots together (Figure 4.2) is an interaction that is difficult to achieve without expert knowledge of their respective APIs.</p>
<p>In comparison to ggvis, the <code>interactr</code> package may not be able to win against its simpler API. <code>ggvis</code> is one of the few packages that uses the <code>shiny</code> infrastructure but does not redraw whenever an input changes. However,</p>
<ul>
<li>could mention that in shiny, whenever they redraw, axes will automatically change. In <code>interactr</code> axes don’t change, so it’s a ‘fair’ comparison (however, if it requires changing, then we’ve got a limitation)</li>
</ul>
<p>Because many of these existing tools are still being developed, it is likely that they may resolve these limitations in the future. However, these tools still require the user to be very familiar with its API. An example of this is the <code>plotly</code> package that has expanded further into achieving linking between other types of plots without the use of crosstalk or shiny and the ability to prevent redrawing when used with <code>shiny</code>. It requires the user to know both the <code>plotly</code> and <code>shiny</code> API, along with some D3 knowledge.</p>
</div>
<div id="future-directions-and-further-problems" class="section level2">
<h2><span class="header-section-number">5.3</span> Future directions and further problems</h2>
<p>The problem of handling large data sets is still present because the browser cannot handle too many SVG elements at once. This is a general problem that occurs across all existing tools. A solution is to render using webGL and HTML canvas environments which allow for many elements to be rendered without compromising speed. However, the problem with this is that it is not as straightforward to attach events to these elements as they are generally treated as a single object.</p>
<p>There is potential in developing <code>interactr</code> further to try achieve complex interactions that are more useful in exploratory data analysis. Currently, only a small number of examples have been successful. There is also a need for making it more simpler and versatile for users without compromising the flexibility in which the user can define interactions. Possible ideas would include integrating plots with <strong>D3</strong> and other <strong>htmlwidgets</strong> to achieve special effects such as zooming and panning of a plot and to achieve multi-directional linking.</p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
