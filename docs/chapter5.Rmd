---
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    pandoc_args: [
      "--number-sections",
      "--number-offset=4"
    ]
---

<br>

```{r, include = FALSE}
library(lattice)
library(interactr)
knitr::opts_chunk$set(comment = NA, warning = FALSE, fig.align = "center",
                      out.extra = "", out.width = "500px")

```

# Discussion

The interactr package provides a way of generating simple interactive R plots that can be viewed in a web browser. It is advantageous in the sense that we can define and customise interactions with flexibility. It can also achieve unidirectional linking between plots. However, there are many limitations present with its current implementation and is not recommended for use yet. It has potential to be further developed in the future.

## Limitations

Firstly, there are limitations that arise from using the gridSVG and DOM packages. With gridSVG, one major limitation is that only grid objects can be converted into SVG. This limits us to plots that must be drawn in R before being sent to the browser. A further limitation is that gridSVG is relatively slow when we try to convert a plot made up of many elements. Currently, work is proceeding to make gridSVG faster.

As interactr is mainly built upon the DOM package, many of its limitations highlighted in Section 3.2 are carried forward. These are generated for a single user in a single session only. Furthermore, because the DOM package is still under development, it cannot be used for production purposes yet. Just as how shiny applications would require a shiny server to be hosted on the web, DOM would require something similar to allow for applications to be shared and accessed. A few trials using a shiny server have been successful, but these only act as a provisional solution. Furthermore, because the underlying system involving requests being sent between R and the web browser, this can be relatively slower when compared to plots that are driven fully by JavaScript.

There are further limitations with its current implementation. The approach is based upon graphical elements produced. This requires the user to be able to link which elements to the data which is more tedious than compared to existing tools that link data to graphical elements on the page. The user must call `listElements` before sending the plot to the browser as it prints the plot and a correct list of elements that make up the plot. This is crucial for plotting systems that do not have a consistent naming scheme. If we reprint the plot, the tags will constantly change which may cause a mismatch between element matching between the plot on the web and the plot in R. Another problem with using `listElements` is that the user will need to deduce which element is on the plot as the naming for these objects in grid may not be clear. If it is a plot that is made directly from grid where the user has named everything clearly, then this is not a problem. The code below shows the difference between the naming scheme in lattice and ggplot2.

Listing the elements from a plot produced with lattice:

```{r}
sp <- xyplot(Petal.Length ~ Petal.Width, data = iris)
listElements(sp)
```

Listing the elements from a plot produced with ggplot2:

```{r}
p <- ggplot(iris) + aes(x = Petal.Width, y = Petal.Length) + geom_point()
listElements(p)
```

Another limitation is the number of interactions that can be attached. So far, the examples expressed in Section 4.3 require a single element to be controlled and assumes that the each grid object listed corresponds to a single SVG element. We can attach many interactions and events to a single element at a time, but not many elements to many different interactions at once. There is a need for a more flexible system when dealing with multiple interactions for achieving more complex interactions. Furthermore, only one kind of interaction can be expressed for a single event. This means that the function created by the user must be fully defined in a single function rather than multiple functions. For example, if a hover requires both adding a tooltip and to turn the element red, then this would need to be written as a single function as we can only attach one to each event.

Code must also be written in a certain order to work. Plots in R must be drawn to a graphics device before being sent to the browser, while a new web page must be set up before we can start adding elements and interactions to the page. These devices must still be open in order to communicate and retrieve existing information about the plot. In cases of dealing with multiple plots, one of the disadvantages is that we lose information about the previous plot in R. This means that the user is required to identify what kind of information they need to extract before they move onto the next plot. This is demonstrated in the example of linking a box plot to other plots together. Before the user can move onto the scatter plot, the range of the box and viewports were stored in order to be used in the defined function. This means that we cannot jump back and forth between plots. A possible solution to this is to store the information about each plot that is sent to the web browser that can be retrievable by the user if needed in R.

A further assumption that the interactr package currently has is that the `native` units in grid represent the data values that are plotted. As discussed in Section 4.3.2, ggplot2 uses a different co-ordinate system and this assumption does not hold. Instead, we would need to take a detour and get the data values that are stored in `ggplot_build()`.

## Comparison to existing tools

interactr's main selling point is the ability to replicate plots or objects drawn in R (in both graphics systems) and to easily achieve on-plot and off-plot interactivity. shiny can do this but you cannot easily attach specific interactions as the plot is rendered as a png. Furthermore, many of these existing tools rely on the shiny framework. As highlighted in Section 2.3, one of the major disadvantages that shiny possesses is a tendency to recompute and redraw entire plots whenever an input changes. In interactr, only part of the plot that the user specifically targets is modified, and customised interactions can be achieved.  It provides a possible way of linking different types of plots together, whereas existing tools, specifically crosstalk, have focused on linked brushing between 'row-observation' data. To put in perspective, the simple example of linking box plots to other types of plots Figure 4.2 is an interaction that is difficult to achieve without expert knowledge of their respective APIs.

In comparison to the existing tools discussed in Section 2, interactr has a more complex API for users. The main reason for this is to increase flexibility across creating different types of interactions and that it is entirely developmental. In comparison to using DOM and gridSVG directly, it provides convenience for certain processes, such as drawing an SVG plot and adding elements to the web page and styling hovers. Currently, only certain interactions highlighted in Section 4.2 can be achieved. There is potential for designing a more simpler and structured API that is more intuitive for developers and users.

An example to highlight this is changing the bandwidth of a density plot (shown below with interactr in Figure 5.1). This example has been replicated with ggvis(Figure 5.2), shiny(Figure 5.3), and with plotly+shiny (Figure 5.4). The animint package will not be able to do this because it is restricted to clicks and selection.

```{r, echo = FALSE, eval = FALSE}
# control a density plot using interactr
plot(density(census$height, bw = 0.1, na.rm = TRUE),
     main = "Density plot of heights",
     xlab = "Heights (cm)")
d.plot <- recordPlot()
listElements(d.plot)
dline <- "graphics-plot-1-lines-1"
draw(d.plot, new.page = TRUE)
#add slider to page:
addSlider("slider", min = 0.1, max = 1, step = 0.05)
#user defined function:
controlDensity <- function(value) {
  showValue(value)
  value <- as.numeric(value)

  dd <- density(census$height, bw = value, na.rm = TRUE)
  x <- dd$x
  y <- dd$y

  #convert coordinates:
  panel <- findPanel(dline)
  pt <- convertXY(x, y, panel)

  # update points:
  setPoints(dline, type = "coords", value = pt)
}
#define and attach interactions:
slideDensity <- sliderCallback(controlDensity)
int <- list(oninput = "slideDensity")
addInteractions("slider", int)
```

```{r, echo = FALSE, fig.cap = "Figure 5.1: control density bandwidth with interactr"}
knitr::include_graphics('./fig/interactr-density.png')
```
**Note: this is a static image.**

```{r, echo = FALSE, eval = FALSE}
# remove missing values
census[is.na(census[, 7]) == 0, ] %>%
ggvis(x = ~height) %>%
layer_densities(adjust = input_slider(0.1, 1, value = 0.1, step = 0.05))
```
```{r, echo = FALSE, fig.cap = "Figure 5.2: control density bandwidth with ggvis"}
knitr::include_graphics('./fig/ggvis-density.png')
```
**Note: this is a static image.**

```{r, echo = FALSE, eval = FALSE}

ui <- basicPage(
  plotOutput("plot"),
  sliderInput("range", "Bandwidth", min = 0.1,
              max = 1, value = 0.1)
)

server <- function(input, output) {
  output$plot <- renderPlot({
    plot(density(census$height, bw = input$range, na.rm = TRUE),
         main = "Density plot of heights",
         xlab = "Heights (cm)")
  })
}

shinyApp(ui, server)

```

```{r, echo = FALSE, out.width = "500px", fig.cap = "Figure 5.3: control density bandwidth with shiny"}
knitr::include_graphics('./fig/shiny-density.png')
```
**Note: this is a static image.**

```{r, echo = FALSE, eval = FALSE}
ui <- basicPage(
  plotlyOutput("plot"),
  sliderInput("range", "Bandwidth", min = 0.1, max = 1, value = 0.1)
)

server <- function(input, output) {
  output$plot <- renderPlotly({
    ggplot(census) + aes(x = height) + geom_density(adjust = input$range)
  })
}

shinyApp(ui, server)
```

```{r, echo = FALSE, fig.cap = "Figure 5.4: control density bandwidth using plotly (rendered with ggplot2) and shiny"}
knitr::include_graphics('./fig/ggplotly-density.png')
```
**Note: this is a static image.**

| Tool       | Approximate number of lines of code | Redraws/reproduces entire plot | Scale of axes change | Plot type rendered|
|:------------:|:------------:|:------------:|:------------:|:----------:|
| interactr  |     18     |     No     |     No     |  base R |
| ggvis      |      3     |     No     |     Yes    |  Vega   |
| plotly+shiny|     10    |    Yes     |    Yes     |  ggplot2 (via ggplotly) |
| shiny      |      10    |    Yes     |     Yes    | base R |

Table 5.1: A comparison table between existing tools and interactr on changing the bandwidth of a density plot

From replicating each example, we find that the interactr package will not change the scale of its axes when the bandwidth is changed. This is because we are only updating the density line relative to the coordinates of the axes. In comparison to the rest of the tools, more lines of code are required to generate the same effect, and those involving shiny reproduce the entire plot every time.

Because many of these existing tools are still being developed, it is likely that they will resolve some of the limitations (discussed in Section 2) in the future. However, they require the user to be very familiar with its API. An example of this is the plotly package that has expanded further into achieving linking between other types of plots and the ability to prevent redrawing when used with shiny. It requires the user to know both the plotly API, shiny, and the `plotlyProxy()` functions as briefly mentioned in Section 2.3.2. The same applies for interactr. There is still a long way to go before we are confident enough to claim that users would not need to know DOM, grid, and gridSVG are used.

## Further problems and future directions

The problem of handling large data sets remains unresolved as the browser cannot handle too many SVG elements at once. This is a general problem that occurs across all existing tools. A solution is to render using webGL and HTML canvas environments which allow for many elements to be rendered without compromising speed. However, the problem with this is that it is not as straightforward to attach events to these elements as they are generally treated as a single object.

There is potential in developing interactr further to try achieve complex interactions that are more useful in exploratory data analysis. Currently, it is only a proof-of-concept and still lacks in many areas. It may become compatible with iNZight as it uses the grid system to produce its plots. However, this requires assessment on how the underlying grid objects are named and drawn before being implemented. Furthermore, only a very small number of examples have been successful and a limited number of interactions can be achieved. There is also a need for a more simpler and versatile system for users without compromising the flexibility in which the user can define interactions. Other possible ideas may include integrating plots with D3 and other htmlwidgets to achieve special effects such as zooming and panning of a plot and to achieve multi-directional linking.
