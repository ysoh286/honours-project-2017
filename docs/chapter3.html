<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title></title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>




<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Report</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="exec-sum.html">Executive Summary</a>
</li>
<li>
  <a href="abstract.html">Abstract</a>
</li>
<li>
  <a href="chapter1.html">1 - Introduction</a>
</li>
<li>
  <a href="chapter2.html">2 - Overview</a>
</li>
<li>
  <a href="chapter3.html">3 - Lower level tools</a>
</li>
<li>
  <a href="chapter4.html">4 - Designing interactr</a>
</li>
<li>
  <a href="chapter5.html">5 - Discussion</a>
</li>
<li>
  <a href="conclusion.html">Conclusion</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">




</div>


<p><br /></p>
<div id="stretching-limitations-with-lower-level-tools" class="section level1">
<h1><span class="header-section-number">3</span> Stretching limitations with ‘lower level’ tools</h1>
<p>Interactions discussed above can be achieved by R users without the knowledge of HTML, CSS and JavaScript. However, we find that more can be achieved if we have some knowledge of these main web technologies. In this section, we discuss more flexible tools that may help us combat these limitations.</p>
<div id="gridsvg" class="section level2">
<h2><span class="header-section-number">3.1</span> gridSVG</h2>
<p>gridSVG (Murrell and Potter, 2017) is an R package that allows for the conversion of grid graphics in R into SVG (Scalable Vector Graphics). This is powerful because in most cases (including plotly and ggvis), plots are rendered in SVG which makes it easy to attach interactions to specific elements on the page. The advantage of using gridSVG over others is that there is a clear mapping structure between data and svg elements generated. This is not present in htmlwidgets and their JavaScript libraries, which makes it hard to identify or trace data back to the elements and vice versa. This also explains why it may be complex to customise interactions on the plot. With gridSVG, we can add javascript to grid elements in R using <code>grid.script()</code> and <code>grid.garnish()</code>, or attach an external javascript file to it after the SVG plot has been generated as we can identify which elements to attach interactions to.</p>
<p><em>Figure: 3.1 simple conversion of a grid plot to an SVG using gridSVG</em></p>
<div id="customising-simple-plot-interactions" class="section level3">
<h3><span class="header-section-number">3.1.1</span> Customising simple plot interactions</h3>
<p>A clear limitation that is present in the existing tools discussed previously allowing the user to customise and make their own interactions on the plot.</p>
<p><em>Figure 3.2: An example of a customised box plot interaction on an iNZight plot using gridSVG, JavaScript</em></p>
<p>One such example is highlighting part of a box plot to show certain values between the median and the lower quartile (Figure 13). While this can be easily achieved with more flexible and lower level tools such as gridSVG and custom JavaScript, it is not with the existing tools such as plotly or ggvis. Despite plotly and ggvis rendering graphs in SVG, we are unable to easily identify which elements to target and add interactions to.</p>
<p>The limitations of this package are clear by its name: only plots that are defined by the <code>grid</code> graphics system can be converted into SVG. This means that plots defined in base R cannot be directly converted. A solution to this is the <code>gridGraphics</code> package which acts as a translator by converting base R graphics into <code>grid</code> graphics. Another point to note is that the process of converting elements to SVG becomes slow if there are many elements to render, which suggests it is not suitable for rendering large data sets.</p>
</div>
<div id="preventing-redraws-in-shiny-using-javascript-messages-and-gridsvg" class="section level3">
<h3><span class="header-section-number">3.1.2</span> Preventing redraws in Shiny using JavaScript messages and gridSVG</h3>
<p>When we interact with a web page, most of these interactions are driven by JavaScript. Shiny provides a way of sending messages from the browser back to R through two different functions: <code>shiny.onInputChange()</code>, <code>Shiny.addCustomMessageHandler</code>.</p>
<p><em>TODO: explain how shiny allows sending between browser + R</em></p>
<p>This gives us a way of targeting certain elements through Shiny when it is not necessary to redraw the entire plot, especially when it comes to plots with many data points. An example of this is the alteration of a trendline using the slider.</p>
<p><em>Figure 14: A replica of Figure 7, but only the trendline changes</em></p>
<p>When we compare Figure 13 back with Figure 7. In Figure 7, the plots are rendered using PNG format and as a single image to which whenever an input is changed (such as whenever the slider moves), the plot is recomputed back in R before being sent back as an image to the browser. In Figure 14, because the plot is rendered as an SVG, we can target only the element that renders the trendline and recompute its coordinates whenever the slider changes.</p>
<p>This solves the problem of being only limited to base plots and ggplot2, as now we can render grid graphics and achieve the same effect, but also customise our own interactions while maintaining a connection between R and the browser using Shiny. However, the main limitation that we face when we render in SVG is that the DOM cannot handle too many SVG elements at once. This compromises the performance and efficiency, thus we are limited to smaller datasets. This is a general problem that occurs across all existing tools. Furthermore, it requires the knowledge of JavaScript and the limitations of how much information can be sent through this ‘channel’ are unknown as it is uncommonly used.</p>
<p><em>Figure 15: Plot a smoother and return selected values</em></p>
<p>To stretch this example further, we added in a feature where the user can highlight over a set of points. When highlighted, we return the information about these points in order to further compute a smoother over these points. To achieve this in shiny, we can add in an external javascript file which can be read and added to the web page.</p>
</div>
</div>
<div id="an-alternative-to-shiny---dom-package" class="section level2">
<h2><span class="header-section-number">3.2</span> An alternative to shiny - DOM package</h2>
<p>The DOM package (Murrell, 2016) is an R package that allows for DOM requests to be sent from R to a browser. It aims to provide a basis for using the web browser as an ‘interactive output device’. It is similar to Shiny as it establishes a connection between R and the browser, however it requires the user to know about the Document Object Model (DOM) and the core web technologies involved. To compare it to Shiny, we have replicated Figure 7 using DOM.</p>
<p><em>Figure 16: DOM example of Figure 14 - changing a trendline</em></p>
<p>The advantages of using DOM over Shiny as seen in this example is that we have control over the entire page. From a developer’s perspective, we can continue to modify elements on the page with ease. This also allows users to still have access to R while the page is running. We can also run a number of interactive web pages in a single R session. In Shiny we are unable to use R in a single session or be able to change it without stopping the application. This creates a way of being able to receive information of what has been interacted with back to R.</p>
<p>However, there are many limitations with this package. As this package is still developmental, only part of the DOM API has been expanded, and the connection between R and the browser requires extra attention. Murrell (2016) states that it can only be run locally and is aimed at a single user rather than multiple users.</p>
<p>In both cases, these interactions cannot be achieved without being able to write JavaScript. gridSVG, DOM and Shiny provide ways in which we can bind custom JavaScript to elements, but requires the user to be able to define what kind of interactions they wish to achieve.</p>
<p>From investigating existing tools, there is a tradeoff between existing tools. It is possible to customise interactions on existing plots, but this requires a knowledge of JavaScript in order to do so. Comparatively, tools that provide standard interactive web plots are easier to use but are complex to modify and extend further.</p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
