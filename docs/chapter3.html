<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title></title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Report</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="abstract.html">Abstract</a>
</li>
<li>
  <a href="exec-sum.html">Executive Summary</a>
</li>
<li>
  <a href="chapter1.html">1 - Introduction</a>
</li>
<li>
  <a href="chapter2.html">2 - Overview</a>
</li>
<li>
  <a href="chapter3.html">3 - Lower level tools</a>
</li>
<li>
  <a href="chapter4.html">4 - Designing interactr</a>
</li>
<li>
  <a href="chapter5.html">5 - Discussion</a>
</li>
<li>
  <a href="conclusion.html">Conclusion</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">




</div>


<p><br /></p>
<div id="stretching-limitations-with-lower-level-tools" class="section level1">
<h1><span class="header-section-number">3</span> Stretching limitations with ‘lower level’ tools</h1>
<p>Interactions discussed above can be achieved by R users without the knowledge of HTML, CSS and JavaScript. However, we find that more can be achieved if we have some knowledge of these main web technologies. In this section, we discuss more flexible tools that may help us combat these limitations.</p>
<div id="gridsvg" class="section level2">
<h2><span class="header-section-number">3.1</span> gridSVG</h2>
<p>gridSVG (Murrell and Potter, 2017) is an R package that allows for the conversion of grid graphics in R into SVG (Scalable Vector Graphics). This is powerful because in most cases (including plotly and ggvis), plots are rendered in SVG which makes it easy to attach interactions to specific elements on the page. The advantage of using gridSVG over others is that there is a clear mapping structure between data and SVG elements generated. This is not present in htmlwidgets and their JavaScript libraries, which makes it hard to identify or trace data back to the elements and vice versa. This also explains why it is difficult to customise interactions on the plot. With gridSVG, we can add javascript to grid elements in R using <code>grid.script()</code> and <code>grid.garnish()</code>, or attach an external javascript file to it after the SVG plot has been generated as we can identify which elements to attach interactions to.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(grid)
<span class="kw">library</span>(gridSVG)

<span class="kw">grid.circle</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">1</span>, <span class="dt">r =</span> <span class="dv">1</span>, <span class="dt">name =</span> <span class="st">&quot;circle.A&quot;</span>, <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">col =</span> <span class="st">&quot;yellow&quot;</span>))
<span class="kw">grid.export</span>(<span class="st">&quot;circle.svg&quot;</span>)</code></pre></div>
<p><em>Figure 3.1: a simple circle (left) drawn in R with grid and its SVG (right) made using gridSVG</em></p>
<p>In the above example, the circle has been originally drawn in R before being exported out as an SVG. A simple interaction has been attached to the circle where if the user can hover over the circle, it will turn red. This demonstrates that there is a a relationship between grid objects and SVG objects that are generated. In R, we can refer back to these grid objects to attach interactions to their SVG counterparts. The naming of these objects are labelled as the ’id’s of these SVG elements.</p>
<div id="customising-simple-plot-interactions" class="section level3">
<h3><span class="header-section-number">3.1.1</span> Customising simple plot interactions</h3>
<p>A clear limitation that is present in the existing tools discussed previously is letting the user add their own interactions on the plot.</p>
<embed src="./fig/bp/boxplot.svg" type="image/svg+xml" />
<p>Figure 3.1.1: An example of a customised box plot interaction on an iNZight plot using gridSVG, JavaScript*</p>
<p>One such example is highlighting part of a box plot to show certain values between the median and the lower quartile (Figure 3.2). While this can be achieved with more flexible and lower level tools such as gridSVG and custom JavaScript, it is not as straightforward with plotly or ggvis. Despite plotly and ggvis rendering graphs in SVG, we are unable to easily identify which elements to target and add interactions to.</p>
<p>The main limitations of this package are clear by its name: only plots that are defined by the <code>grid</code> graphics system can be converted into SVG. This means that plots defined in base R cannot be directly converted. Another point to note is that the process of converting elements to SVG becomes slow if there are many elements to render.</p>
</div>
<div id="preventing-redraws-in-shiny-using-javascript-messages-and-gridsvg" class="section level3">
<h3><span class="header-section-number">3.1.2</span> Preventing redraws in Shiny using JavaScript messages and gridSVG</h3>
<p>When we interact with a web page, most of these interactions are driven by JavaScript. Shiny provides a way of sending messages from the browser back to R through two different functions: <code>shiny.onInputChange()</code>, <code>Shiny.addCustomMessageHandler</code>.</p>
<p><em>TODO: explain how shiny allows sending between browser + R</em></p>
<p>This gives us a way of targeting certain elements through Shiny when it is not necessary to redraw the entire plot, especially when it comes to plots with many data points. An example of this is the alteration of a trend line using the slider.</p>
<div class="figure">
<img src="fig/tl-shiny.png" alt="Figure 3.1.2: A replica of Figure 2.1.3, but only the trendline changes" />
<p class="caption">Figure 3.1.2: A replica of Figure 2.1.3, but only the trendline changes</p>
</div>
<p>When we compare Figure 3.1.2 back with Figure 7. In Figure 7, the plots are rendered using PNG format and as a single image to which whenever an input is changed (such as whenever the slider moves), the plot is recomputed back in R before being sent back as an image to the browser. In Figure 14, by using gridSVG to generate the SVG plot, we can pinpoint the line the makes up the smoother on the plot and recompute its coordinates whenever the slider changes.</p>
<p>This solves the problem of being only limited to base plots and ggplot2, as now we can render grid graphics and achieve the same effect, but also customise our own interactions while maintaining a connection between R and the browser using Shiny. However, it requires the knowledge of JavaScript and the limitations of how much information can be sent through this channel are unknown as it is uncommonly used.</p>
<p>To stretch this example further, we added in a feature where the user can highlight over a set of points. When highlighted, we return the information about these points in order to further compute a smoother over these points. To achieve this in shiny, we have written some JavaScript that returns the index of these selected points back to R which are then used to compute a suitable smoother that is then displayed.</p>
<div class="figure">
<img src="fig/tl-shiny-2.png" alt="Figure 3.1.3: Select over a set a points to show a smoother" />
<p class="caption">Figure 3.1.3: Select over a set a points to show a smoother</p>
</div>
<p><strong>Click <a href="https://ysoh286.shinyapps.io/shiny-trendline-brush/">here</a> to view the shiny application of this example.</strong></p>
</div>
</div>
<div id="dom-package" class="section level2">
<h2><span class="header-section-number">3.2</span> DOM package</h2>
<p>The DOM package (Murrell, 2016) is an R package that allows for DOM (Document Object Model) requests to be sent from R to a browser. It aims to provide a basis for using the web browser as an ‘interactive output device’.</p>
<p>Using DOM allows us to write certain commands that would be analogous to what we would write in JavaScript. Going back to our circle example in Figure 3.1, we can achieve the same effect by directly sending this request to the web page rather than binding JavaScript and exporting.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(DOM)
page &lt;-<span class="st"> </span><span class="kw">htmlPage</span>()
<span class="kw">grid.circle</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dt">name =</span> <span class="st">&quot;circle&quot;</span>)
svg &lt;-<span class="st"> </span><span class="kw">grid.export</span>(<span class="ot">NULL</span>)<span class="op">$</span>svg
<span class="kw">appendChild</span>(page, svg, ...)
circle &lt;-<span class="st"> </span><span class="kw">getElementById</span>(page, <span class="st">&quot;circle.1.1&quot;</span>)
<span class="kw">setAttribute</span>()</code></pre></div>
<p>In contrast, the JavaScript code for changing this circle from yellow to red:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> circle <span class="op">=</span> <span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&#39;circle.1.1&#39;</span>)<span class="op">;</span>
<span class="va">circle</span>.<span class="at">setAttribute</span>(fill<span class="op">,</span> <span class="st">&quot;red&quot;</span>)<span class="op">;</span></code></pre></div>
<script type="text/javascript">
var circle = document.getElementById('circle.1.1');
circle.setAttribute(fill, "red");
</script>
<p>Furthermore, DOM is similar to shiny as it establishes a connection between R and the browser. However it is considered much more ‘lower level’ as it requires the user to know about the DOM and the core web technologies involved. To compare it to shiny, we have replicated Figure 7 using DOM.</p>
<p><em>add a gif, or video?</em> <strong>Figure 16: DOM example of Figure 14 - changing a trendline</strong></p>
<p>The process of creating this example is similar to shiny, however it is more complex as it require the user to be able to link elements manually. First, we draw the plot and save it as an SVG in memory. This is the same code that was used in Figure 7. Next, send the SVG plot to the web page, and add sliders, text, and write custom JavaScript for controlling certain effects. We identify which element corresponds to the trend line, and write functions to define how and what happens when the slider moves or the text is clicked. In this example, the functions recalculate the coordinates of the trend line and this is updated on the web page.</p>
<p>The advantages of using DOM over Shiny as seen in this example is that we have control over the entire page. From a developer’s perspective, we can continue to modify elements on the page. This also allows users to still have access to R while the page is running. We can also run a number of interactive web pages in a single R session. In shiny we are unable to use R in a single session or be able to change it without stopping the application. This allows information to be sent from the web browser and captured back in R. However, there is more effort that needs to be placed into linking different tools together to create the same example. The DOM example requires a lot more code and requires the user to be able to link everything together, where as in shiny, these links are much easier to co-ordinate.</p>
<p>Internally, there are many limitations with this package. As this package is still developmental, only part of the DOM API has been expanded, and the connection between R and the browser requires extra attention. Murrell (2016) states that it can only be run locally and is aimed at a single user rather than multiple users.</p>
<p>In both cases, these interactions cannot be achieved without being able to write JavaScript. gridSVG, DOM and shiny provide ways in which we can bind custom JavaScript to elements, but requires the user to be able to define what kind of interactions they wish to achieve.</p>
<p>There is a tradeoff between existing tools. It is possible to customise interactions on existing plots, but this requires a knowledge of JavaScript in order to do so. Comparatively, tools that provide standard interactive web plots are easier to use but are complex to modify and extend further.</p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
