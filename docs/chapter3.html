<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title></title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Report</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="abstract.html">Abstract</a>
</li>
<li>
  <a href="exec-sum.html">Executive Summary</a>
</li>
<li>
  <a href="chapter1.html">1 - Introduction</a>
</li>
<li>
  <a href="chapter2.html">2 - Overview</a>
</li>
<li>
  <a href="chapter3.html">3 - Lower level tools</a>
</li>
<li>
  <a href="chapter4.html">4 - Designing interactr</a>
</li>
<li>
  <a href="chapter5.html">5 - Discussion</a>
</li>
<li>
  <a href="conclusion.html">Conclusion</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">




</div>


<p><br /></p>
<div id="interactive-r-plots-using-lower-level-tools" class="section level1">
<h1><span class="header-section-number">3</span> Interactive R plots using lower level tools</h1>
<p>Web interactive graphics can be achieved by R users without the knowledge of HTML, CSS and JavaScript. However, many of these tools involved generally do not preserve plots that are drawn in R and continually redraw each time the user interacts with it. This section discusses how we can use two lower level packages, gridSVG and DOM, along with a knowledge of web technologies to incorporate interactions into R plots and prevent redrawing.</p>
<p>One approach to avoid redrawing in plots is to target parts of the plot that need to be updated. We need a system that renders SVG elements but has a mapping structure that allows elements be related back to data. In R, we can use the gridSVG package.</p>
<div id="gridsvg" class="section level2">
<h2><span class="header-section-number">3.1</span> gridSVG</h2>
<p>gridSVG (Murrell and Potter, 2017) is an R package that allows for the conversion of grid graphics in R into SVG. This is powerful because it is easy to attach interactions to specific elements on the page. The advantage of using gridSVG over others is that there is a clear mapping structure between data and SVG elements generated. This is not clear in plotly or ggvis and their JavaScript libraries, which makes it hard to identify or trace data back to the elements on the page. This also explains why it may be difficult to customise interactions on the plot. With gridSVG, we can add JavaScript to grid elements in R using <code>grid.script()</code> and <code>grid.garnish()</code> (Murrell and Potter, 2011).</p>
<embed src="./fig/circle.svg" type = "image/svg+xml" width = "200"/>
<p>Figure 3.1: an interactive circle made using gridSVG</p>
<p><strong>Hover over the circle above and it will turn red!</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">grid.circle</span>(<span class="dt">x =</span> <span class="fl">0.5</span>, <span class="dt">y =</span> <span class="fl">0.5</span>, <span class="dt">r =</span> <span class="fl">0.25</span>, <span class="dt">name =</span> <span class="st">&quot;circle.A&quot;</span>, <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">fill =</span> <span class="st">&quot;yellow&quot;</span>))
<span class="kw">grid.garnish</span>(<span class="st">&#39;circle.A&#39;</span>, <span class="dt">onmouseover =</span> <span class="st">&quot;allred()&quot;</span>, <span class="dt">onmouseout =</span> <span class="st">&quot;allyellow()&quot;</span>, <span class="st">&quot;pointer-events&quot;</span> =<span class="st"> &quot;all&quot;</span>)
<span class="kw">grid.script</span>(<span class="st">&quot;allred = function() {</span>
<span class="st">  var circle = document.getElementById(&#39;circle.A.1.1&#39;);</span>
<span class="st">  circle.setAttribute(&#39;fill&#39;, &#39;red&#39;);</span>
<span class="st">  }&quot;</span>)
<span class="kw">grid.script</span>(<span class="st">&quot;allyellow = function() {</span>
<span class="st">  var circle = document.getElementById(&#39;circle.A.1.1&#39;);</span>
<span class="st">  circle.setAttribute(&#39;fill&#39;, &#39;yellow&#39;);</span>
<span class="st">  }&quot;</span>)
<span class="kw">grid.export</span>(<span class="st">&quot;circle.svg&quot;</span>)</code></pre></div>
<p>In Figure 3.1, the circle has been originally drawn in R before being exported out as an SVG. A simple interaction has been attached to the circle where if the user hovers over the circle, it will turn red. This shows that there is a relationship between grid objects and SVG objects that are generated. In grid, we have named the circle as <code>circle.A</code>. gridSVG maintains this as an grouped SVG element with an id attribute of <code>circle.A.1</code>, where inside lies a single SVG circle element called <code>circle.A.1.1</code>. In R, we can refer back to these grid objects to attach interactions to their SVG counterparts.</p>
<p>Another important feature that gridSVG has is the ability to translate between data and SVG coordinates. Suppose that a plot has been generated. The <code>exportCoords</code> argument in <code>grid.export</code> is able to generate data that retains the locations of viewports and scales in the plot (Murrell and Potter, 2012). We can use this information to convert data to SVG coordinates.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lattice<span class="op">::</span><span class="kw">xyplot</span>(dist <span class="op">~</span><span class="st"> </span>speed, <span class="dt">data =</span> cars)</code></pre></div>
<p><img src="chapter3_files/figure-html/unnamed-chunk-2-1.png" width="672"  style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">svgdoc &lt;-<span class="st"> </span><span class="kw">grid.export</span>(<span class="ot">NULL</span>, <span class="dt">exportCoords =</span> <span class="st">&quot;inline&quot;</span>)

<span class="co">#separate svg and coordinates</span>
svg &lt;-<span class="st"> </span>svgdoc<span class="op">$</span>svg
coords &lt;-<span class="st"> </span>svgdoc<span class="op">$</span>coords

gridSVG<span class="op">::</span><span class="kw">gridSVGCoords</span>(coords)
panel &lt;-<span class="st"> &quot;plot_01.toplevel.vp::plot_01.panel.1.1.vp.2&quot;</span>

<span class="co">#if there&#39;s a new point we want to find the SVG coordinates of:</span>
(x &lt;-<span class="st"> </span><span class="kw">viewportConvertX</span>(panel, <span class="dv">4</span>, <span class="st">&quot;native&quot;</span>))</code></pre></div>
<pre><code>## [1] 79.48421</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(y &lt;-<span class="st"> </span><span class="kw">viewportConvertY</span>(panel, <span class="dv">5</span>, <span class="st">&quot;native&quot;</span>))</code></pre></div>
<pre><code>## [1] 73.45</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># to translate back to data (ie native):</span>
<span class="kw">viewportConvertX</span>(panel, x, <span class="st">&quot;svg&quot;</span>, <span class="st">&quot;native&quot;</span>)</code></pre></div>
<pre><code>## [1] 4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">viewportConvertY</span>(panel, y, <span class="st">&quot;svg&quot;</span>, <span class="st">&quot;native&quot;</span>)</code></pre></div>
<pre><code>## [1] 5</code></pre>
<p>In the example above, we have drawn a plot using the cars dataset and exported its coordinates system with its corresponding SVG. Suppose we have a new point at (4, 5). This can be easily translated into SVG co-ordinates and back using the functions <code>viewportConvertX</code> and <code>viewportConvertY</code> along with the correct viewport identified as <code>panel</code> where the points lie on the plot. Here, the native co-ordinates (4, 5) have been translated as (79.4842105, 73.45) in the SVG co-ordinate system. This can be further added to the plot as we have the co-ordinates in the SVG space using JavaScript.</p>
<p>The main limitations of this package are clear by its name: only plots that are defined by the <code>grid</code> graphics system can be converted into SVG. This means that plots defined using <code>graphics</code> cannot be directly converted. Another point to note is that the process of converting elements to SVG becomes slow when there are many elements to render.</p>
<div id="customising-simple-plot-interactions" class="section level3">
<h3><span class="header-section-number">3.1.1</span> Customising simple plot interactions</h3>
<p>A clear limitation that is present in the existing tools discussed previously is letting the user add their own interactions on the plot.</p>
<embed src="./fig/bp/boxplot.svg" type="image/svg+xml" />
<p>Figure 3.2: An example of a customised box plot interaction on an iNZight plot using gridSVG, JavaScript</p>
<p><strong>Hover over Figure 3.2’s box and it will light up in red. Click on the box to highlight the points that lie within that range.</strong></p>
<p>One such example is highlighting part of a box plot to show certain values between the median and the lower quartile (Figure 3.2). When the user clicks on this box, it will highlight the points that lie within this range. While this can be achieved with gridSVG and custom JavaScript, it is not as straightforward with plotly or ggvis. Despite plotly and ggvis rendering graphs in SVG, we are unable to identify which elements to target and add interactions to.</p>
</div>
<div id="preventing-redraws-in-shiny-using-javascript-messages-and-gridsvg" class="section level3">
<h3><span class="header-section-number">3.1.2</span> Preventing redraws in Shiny using JavaScript messages and gridSVG</h3>
<p>As mentioned in Chapter 2, one of the downsides for using shiny (with or without htmlwidgets) is its nature to redraw plots every time an input changes. In the case of R plots that are rendered using <code>renderPlot</code> ffunction, redrawing is required because the plot is viewed as a raster image. This means that we cannot specifically target elements on the page as the image is viewed as a single object. A way to get around this is to render the plot in SVG using gridSVG.</p>
<p>A complication to this is that we can no longer use the usual input and output functions that link everything on the page. To control specific elements on the page, we need a different way of passing data between the browser and back to R using JavaScript. shiny provides a way of sending messages through this channel using two JavaScript functions: <code>shiny.onInputChange()</code> and <code>shiny.addCustomMessageHandler()</code>. To send data from the browser back to R, we use <code>shiny.onInputChange()</code>. This allows JavaScript objects to be sent back to the shiny server that can be recognised in R. To send data from R back to the browser, we use <code>shiny.addCustomMessageHandler()</code>.</p>
<p>To demonstrate how this is useful in updating certain parts of a plot, we provide an example by altering the trend line using gridSVG and these JavaScript functions. First, we use gridSVG to generate our plot and identify the element corresponding to the trend line. We also need to export the coordinates in order to be able to transform data into the correct SVG coordinates when we update the co-ordinates of trend line.</p>
<div class="figure" style="text-align: center">
<img src="fig/tl-shiny-diagram.svg" alt="Figure 3.3: diagram of how things work using shiny's JavaScript functions in Figure 3.4"  />
<p class="caption">
Figure 3.3: diagram of how things work using shiny’s JavaScript functions in Figure 3.4
</p>
</div>
<p>In Figure 3.3, we can pass the value of the slider back to R (either through inputs or <code>shiny.onInputChange</code>) which is then used to recalculate the x and y co-ordinates of the smoother. Once these co-ordinates are calculated, they are sent back to the browser using <code>session$sendCustomMessage</code>. These coordinates are passed to <code>shiny.addCustomMessageHandler()</code> to run a JavaScript function that will update the points of the line. This process is used in Figure 3.4 with a lattice plot of the iris data set.</p>
<div class="figure" style="text-align: center">
<img src="fig/tl-shiny.png" alt="Figure 3.4: A replica of Figure 2.7, but only the trendline changes" width="700px"  />
<p class="caption">
Figure 3.4: A replica of Figure 2.7, but only the trendline changes
</p>
</div>
<p><strong>This is a static image. Click <a href="https://ysoh286.shinyapps.io/shiny-trendline-brush/">here</a> to view the shiny application of this example.</strong></p>
<p>This example (Figure 3.4) is extensible as we can render grid graphics (such as lattice) and customise interactions while maintaining a connection between R and the browser using shiny. Rather than redrawing the entire plot, we have only changed the trend line. However, this method requires the knowledge of JavaScript and the limitations of how much information can be sent through are unknown as it is uncommonly used.</p>
<p>To stretch this example further, we added in a feature where the user can highlight over a set of points (as seen in Figure 3.5). When highlighted, we return the information about these points in order to further compute a smoother over these points. To achieve this in shiny, we have written some JavaScript that returns the index of these selected points back to R with <code>shiny.onInputChange()</code> to compute a suitable smoother that is then displayed.</p>
<div class="figure" style="text-align: center">
<img src="fig/tl-shiny-2.png" alt="Figure 3.5: Select over a set a points to show a smoother" width="700px"  />
<p class="caption">
Figure 3.5: Select over a set a points to show a smoother
</p>
</div>
<p><strong>This is a static image. Click <a href="https://ysoh286.shinyapps.io/shiny-trendline-brush/">here</a> to view the shiny application of this example.</strong></p>
</div>
</div>
<div id="dom-package" class="section level2">
<h2><span class="header-section-number">3.2</span> DOM package</h2>
<p>The DOM package (Murrell, 2016) is an R package that allows for DOM (Document Object Model) requests to be sent from R to a browser. It aims to provide a basis for using the web browser as an ‘interactive output device’ (Murrell, 2016a).</p>
<p>Using DOM allows us to write certain commands that are analogous to what is written in JavaScript. This removes the burden of traversing between the two programming languages. Rather than writing JavaScript, we can write DOM commands in R that produce similar results. Going back to our circle example in Figure 3.1, we can change the colour of the circle by directly sending this request to the web page.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(DOM)
page &lt;-<span class="st"> </span><span class="kw">htmlPage</span>()
<span class="kw">grid.circle</span>(<span class="dt">x =</span> <span class="fl">0.5</span>, <span class="dt">y =</span> <span class="fl">0.5</span>, <span class="dt">r =</span> <span class="fl">0.25</span>, <span class="dt">name =</span> <span class="st">&quot;circle.A&quot;</span>, <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">fill =</span> <span class="st">&quot;yellow&quot;</span>))
svg &lt;-<span class="st"> </span><span class="kw">grid.export</span>(<span class="ot">NULL</span>)<span class="op">$</span>svg
<span class="kw">appendChild</span>(page,
            <span class="dt">child =</span> <span class="kw">svgNode</span>(XML<span class="op">::</span><span class="kw">saveXML</span>(svg)),
            <span class="dt">ns =</span> <span class="ot">TRUE</span>,
            <span class="dt">response =</span> <span class="kw">svgNode</span>())
circle &lt;-<span class="st"> </span><span class="kw">getElementById</span>(page, <span class="st">&quot;circle.A.1.1&quot;</span>, <span class="dt">response =</span> <span class="kw">nodePtr</span>())
<span class="kw">setAttribute</span>(page, circle, <span class="st">&quot;fill&quot;</span>, <span class="st">&quot;red&quot;</span>)</code></pre></div>
<p>In contrast, the JavaScript code for changing this circle from yellow to red:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> circle <span class="op">=</span> <span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&#39;circle.A.1.1&#39;</span>)<span class="op">;</span>
<span class="va">circle</span>.<span class="at">setAttribute</span>(fill<span class="op">,</span> <span class="st">&quot;red&quot;</span>)<span class="op">;</span></code></pre></div>
<script type="text/javascript">
var circle = document.getElementById('circle.A.1.1');
circle.setAttribute(fill, "red");
</script>
<p>DOM allows R to be called from the browser and for requests from R to be sent to the browser. To demonstrate this, we will replicate the hover effects on the circle as shown in Figure 3.1. Figure 3.6 shows how this can be set up using DOM. We can use <code>setAttribute</code> to set the colour of the circle, and use the <code>RDOM.Rcall</code> function to send requests from the browser back to R. When the user hovers over the circle, the browser will send a request back to R to run the <code>turnRed</code> function, which in turn sends a request back to the browser to change the colour of the circle to red. Once the user hovers out, the browser will send a request back to R to turn it back to yellow. Our result is shown in Figure 3.7.</p>
<div class="figure" style="text-align: center">
<img src="fig/circle-DOM-diagram.svg" alt="Figure 3.6: Simple diagram showing how DOM works with from replicating Figure 3.1"  />
<p class="caption">
Figure 3.6: Simple diagram showing how DOM works with from replicating Figure 3.1
</p>
</div>
<div class="figure" style="text-align: center">
<img src="fig/circle-DOM-1.png" alt="Figure 3.7: DOM example of Figure 3.1 - when hovered, the circle turns red (right)" width="200px"  />
<p class="caption">
Figure 3.7: DOM example of Figure 3.1 - when hovered, the circle turns red (right)
</p>
</div>
<p><strong>Note: this is a static image.</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#draw circle in grid</span>
grid<span class="op">::</span><span class="kw">grid.circle</span>(<span class="dt">x =</span> <span class="fl">0.5</span>, <span class="dt">y =</span> <span class="fl">0.5</span>, <span class="dt">r =</span> <span class="fl">0.25</span>, <span class="dt">name =</span> <span class="st">&quot;circle.A&quot;</span>, <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">fill =</span> <span class="st">&quot;yellow&quot;</span>))
<span class="co">#export SVG</span>
svg &lt;-<span class="st"> </span>gridSVG<span class="op">::</span><span class="kw">grid.export</span>(<span class="ot">NULL</span>)<span class="op">$</span>svg
<span class="kw">dev.off</span>()

<span class="co">#set up new page and add circle:</span>
<span class="kw">library</span>(DOM)
page &lt;-<span class="st"> </span><span class="kw">htmlPage</span>()
<span class="kw">appendChild</span>(page,
            <span class="dt">child =</span> <span class="kw">svgNode</span>(XML<span class="op">::</span><span class="kw">saveXML</span>(svg)),
            <span class="dt">ns =</span> <span class="ot">TRUE</span>,
            <span class="dt">response =</span> <span class="kw">svgNode</span>())

circle &lt;-<span class="st"> </span><span class="kw">getElementById</span>(page, <span class="st">&quot;circle.A.1.1&quot;</span>, <span class="dt">response =</span> <span class="kw">nodePtr</span>())
<span class="co"># hover effects:</span>
turnRed &lt;-<span class="st"> </span><span class="cf">function</span>(ptr) {
  <span class="kw">setAttribute</span>(page,
              circle,
              <span class="st">&quot;fill&quot;</span>,
              <span class="st">&quot;red&quot;</span>,
              <span class="dt">async =</span> <span class="ot">TRUE</span>)
}

turnYellow &lt;-<span class="st"> </span><span class="cf">function</span>(ptr) {
  <span class="kw">setAttribute</span>(page,
              circle,
              <span class="st">&quot;fill&quot;</span>,
              <span class="st">&quot;yellow&quot;</span>,
              <span class="dt">async =</span> <span class="ot">TRUE</span>)
}

<span class="kw">setAttribute</span>(page,
             circle,
             <span class="st">&quot;onmouseover&quot;</span>,
             <span class="st">&quot;RDOM.Rcall(&#39;turnRed&#39;, this, [&#39;ptr&#39;], null)&quot;</span>)

<span class="kw">setAttribute</span>(page,
             circle,
             <span class="st">&quot;onmouseout&quot;</span>,
             <span class="st">&quot;RDOM.Rcall(&#39;turnYellow&#39;, this, [&#39;ptr&#39;], null)&quot;</span>)</code></pre></div>
<p>The example (Figure 3.7) takes approximately 40 lines of code for a hover effect. It is much more ‘lower level’ and requires the user to know how the Document Object Model and main web technologies work together.</p>
<div id="comparing-dom-to-shiny" class="section level3">
<h3><span class="header-section-number">3.2.1</span> Comparing DOM to shiny</h3>
<p>DOM is similar to shiny as it establishes a connection between R and the browser. To compare, we have replicated Figure 3.4 using DOM.</p>
<div class="figure" style="text-align: center">
<img src="fig/tl-DOM-diagram.svg" alt="Figure 3.8: Steps on how a trend line can be altered using the DOM package"  />
<p class="caption">
Figure 3.8: Steps on how a trend line can be altered using the DOM package
</p>
</div>
<p>The process of creating this example is similar to what was done with shiny. However, it is more difficult to set up as it requires the user to manually link all the components on the page. First, we draw the plot and save it as an SVG in memory. Next, we can add the SVG plot and a slider to the page. We identify which element corresponds to the trend line, and define what happens when the slider moves or when text is clicked. This requires an additional query to the browser to return the value of the slider before it can be returned back to R, as shown in in Figure 3.8. These are co-ordinated using asynchronous callbacks, where once a response is returned, we can schedule another task behind it. These are viewed as a series of steps that are linked together. Once the value of the slider is returned, we can use it to recalculate the coordinates of the trend line before updating it on the page. Our final result is put together in Figure 3.9.</p>
<div class="figure" style="text-align: center">
<img src="fig/tl-DOM-2.png" alt="Figure 3.9: DOM example of Fig 3.4 for changing a trendline using a slider" width="400px"  />
<p class="caption">
Figure 3.9: DOM example of Fig 3.4 for changing a trendline using a slider
</p>
</div>
<p><strong>Note: this is a static image.</strong></p>
<p>DOM allows for more flexibility as we have control over the entire page. From a developer’s perspective, we can continue to modify elements on the page. Users have access to R while the the connection to the web page is running. We can also run a number of interactive web pages in a single R session. In shiny, we are unable to use R in a single session or be able to change it without stopping the application. However, the DOM example requires a lot more code to link everything together. In shiny, these links between inputs and outputs are much easier to co-ordinate.</p>
<p>Internally, there are many limitations with this package. As this package is still developmental, only part of the DOM (Document Object Model) API has been expanded, and the connection between R and the browser requires extra attention. In some cases, it is still not possible to achieve certain interactions without JavaScript, such as capturing where the mouse’s position is on screen. Murrell (2016a) states that it can only be run locally and is currently aimed at a single user rather than multiple users.</p>
<p>In both cases, these interactions cannot be achieved without the ability to write JavaScript. gridSVG, DOM and shiny provide ways in which we can bind custom JavaScript to elements, but requires the user to be able to define what kind of interactions they wish to achieve.</p>
<p>There is a clear trade off between existing tools. It is possible to customise interactions on existing plots, but this requires a knowledge of JavaScript in order to do so. Comparatively, tools that provide standard interactive web plots are easier to use but are complex to modify and extend further.</p>
</div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
