## Summary Tables

Just to recap what I've learnt so far in the past month & a half. (Week 1-Week 6)


**These may be updated to make sure that the information is (hopefully) correct, and in case if any of these new technologies change/or  I find something new.**


| Comparison  | Similarities     | Differences   |
|:------------| :-------------   | :-------------|
| Shiny vs Crosstalk    |   Allow users to control and communicate information between plots and other inputs/outputs (such as tables, sliders, e.t.c).    | Crosstalk's aim is to link HTML widgets seamlessly together and to be a solution for linking multiple co-ordinated views automatically (Cheng, 2016 - useR Conference). Crosstalk limited to two features, you can achieve much more with Shiny.  Shiny requires R session to power everything, crosstalk is more standalone and easy to share. Data is all stored in a single static page using crosstalk, while data is running on the server side in Shiny. |
| Plotly vs ggvis | Construction of plots using layers, use of pipeline operator %>% (functional in the sense where you can constantly modify plots by storing plot objects in variables), compatible with Shiny, both provide in-plot interactions, construction of facetted and multi-panel plots are relatively similar (via subplots/subvis). No support for 1 variable dotplots (programmed to look for a y-variable). Both support a wide variety of plots. Both use JS libraries/APIs that are built upon D3.     | ggvis can provide out-plot interactions, while Plotly alone cannot. Vega vs Plotly.js. ggvis interactions are driven through R, Plotly interactions driven by JS. No support for facetted plots for ggvis(yet!). For Plotly, facetted plots achievable using ggplotly() + ggplot2 or subplot().        |
| ggvis vs Shiny | Both use R sessions to drive interactions (in fact, ggvis communicates between R and the web browser via Shiny), very similar inputs and interactions can be achieved. | ggvis does not allow layout control, Shiny does. ggvis allows for some basic in-plot interactions to be achieved, while Shiny does not. ggvis has limitations on its interactivity - you cannot add/remove layers, and interactivity can only be added on 'arguments' and 'properties', but not on the data (as explained [here](http://ggvis.rstudio.com/interactivity.html#limitations)). |


| | Pros/Strengths        | Cons/Weaknesses | Comments? |
|:---------- | :--------- | :-----------| :---------|
| Shiny | Generic, allows UI and layouts on the page to be easily customised, has several functions to easily construct an HTML page/ user interface using the Bootstrap framework, out-plot interactions  , popular for incorporating interactions via R without the need to learn other web technologies. Can easily be connected with other packages such as Plotly, ggvis. Extensible to using R for statistical computing.  |  Rerunning code and redrawing plots (inefficient on large datasets),  limited on in-plot interactions. Linked brushing (via brushedPoints) only works on base plots and ggplot2 - may be supported through other packages in their own way (plotly: plotly_selected, ggvis: linked_brush).  | Been around for quite a while (since 2012). |
| Crosstalk | Great with dealing with row-observation data, no reliance on R (standalone sense), great for linked brushing and filtering , easy to link up tables to plots via making data frame as shared key objects. It achieves linked co-ordinated views (of the same data) easily. Selection may not require redrawing. Allows for faster interactivity.  |  Does not work on aggregated and summarised data (+ cannot do all the other things you could do in R such as model fitting, smoothing...), hard to implement (requires set up through R on your own widget + JS), selection and filtering must be well defined through JS interactions, only has two features so far: selection/linked brushing and filtering. May require redrawing of plots (depends on how author has defined JS interactions and what it does with the data). Currently supported HTMLwidgets: Plotly, Leaflet, d3scatter, DT. Storage may become a problem - standalone HTML pages can become big in size especially when you're dealing with big datasets as all the data is stored in that one single HTML page. Becomes slow and inefficient when you have too many data points.  |   Still in development, relatively new (launched in 2016, currently experimental).  |
