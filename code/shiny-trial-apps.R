# WEEK3 - TESTING BRUSHEDPOINTS() AND THE LIMITS TO SHINY'S INTERACTIVE FUNCTIONS.

# Dev version of Shiny works for ggplot2! CRAN version works for base plots. 

devtools::install_github('rstudio/shiny')
library(shiny)
library(ggplot2)

## load some datasets:
income <- read.csv('~/Desktop/datasets/nzincome.csv', header = TRUE)
census <- read.csv('~/Desktop/datasets/census.csv', header = TRUE)
income100 <- income[1:100, ]

## test if you can switch to ggplots?

ui <- basicPage(
  
  plotOutput("plot", brush = "plot_brush"),
  verbatimTextOutput("info")
)

server <- function(input, output) {
  
  output$plot <- renderPlot({
    ggplot(iris, aes(x = Petal.Width, y = Petal.Length))  + geom_point()
  })
  
  output$info <- renderPrint({
    brushedPoints(iris, input$plot_brush, xvar = "Petal.Width", yvar = "Petal.Length") 
  })
}

shinyApp(ui, server)

#----------------------------------------------------------------------------

# Linking it to plot and table - which works:

ui <- basicPage(
  plotOutput("plot", brush = "plot_brush"),
  tableOutput("iris_table")
)

server <- function(input, output) {
  
  output$plot <- renderPlot({
    ggplot(iris, aes(x = Petal.Width, y = Petal.Length)) + geom_point()
  })
  
  output$iris_table <- renderTable({
    brushedPoints(iris, input$plot_brush, xvar = "Petal.Width", yvar = "Petal.Length")
    })
}

shinyApp(ui, server)


#----------------------------------------------------------------------------

##Can you do it on facetted plots (ggplot2)? 
##- example adapted from https://shiny.rstudio.com/articles/selecting-rows-of-data.html

ui <- basicPage(
  plotOutput("plot", brush = "plot_brush"),
  tableOutput("iris_table")
)

server <- function(input, output) {
  
  output$plot <- renderPlot({
    ggplot(iris, aes(x = Petal.Width, y = Petal.Length, color = Species)) + geom_point() + facet_grid(.~Species)
  })
  
  output$iris_table <- renderTable({
    brushedPoints(iris, input$plot_brush, xvar = "Petal.Width", yvar = "Petal.Length")
  })
  
}

shinyApp(ui, server)

#----------------------------------------------------------------------------

##FACETTED PLOT #2:
## trying with a more complex dataset - and it works on facetted plots created by ggplot2...
income <- read.csv('~/Desktop/datasets/nzincome.csv', header = TRUE)
income100 <- income[1:100, ]


ui <- basicPage(
  plotOutput("plot", brush = "plot_brush"),
  tableOutput("income_table")
)

server <- function(input, output) {
  output$plot <- renderPlot({
    ggplot(income100, aes(x = weekly_hrs, y= weekly_income, color = sex)) + geom_point() + facet_grid(.~ethnicity)
  })
  
  output$income_table <- renderTable({
    brushedPoints(income100, input$plot_brush, xvar = "weekly_hrs", yvar = "weekly_income")
  })
}

shinyApp(ui, server)

#----------------------------------------------------------------------------

#FACETTED PLOT 3:
## but it kind of starts to falter  on datasets with missing values - removes missing values automatically - but the table shows NAs... 
census <- read.csv('~/Desktop/datasets/census.csv', header = TRUE)

ui <- basicPage(
  plotOutput("plot", brush = "plot_brush"),
  tableOutput("census_table")
)

server <- function(input, output) {
  output$plot <- renderPlot({
    ggplot(census, aes(x = armspan, y = height, color = gender)) + geom_point() + facet_grid(.~cellsource)
  })
  
  output$census_table <- renderTable({
    brushedPoints(census, input$plot_brush, xvar = "armspan", yvar = "height")
  })
  
}

shinyApp(ui, server)


#--------------------------------------------------------------------------------------------

#Could you do it with lattice?

library(lattice)
ui <- basicPage(
  plotOutput("plot", click = "plot_click", brush = "plot_brush"),
  verbatimTextOutput("info"),
  tableOutput("income_table")
)

server <- function(input, output) {
  output$plot <- renderPlot({
    x <- income100$weekly_hrs
    y <- income100$weekly_income
    xyplot(y~x,  main = "Lattice scatterplot of nzincome", ylab ="Weekly income", xlab = "Weekly hrs")
  })
  
  output$info <- renderText({
    paste0("Weekly_hrs=", input$plot_click$x, "\n Weekly_income=", input$plot_click$y)
  })
  
  output$income_table <- renderTable({
    brushedPoints(income100, input$plot_brush, xvar = "weekly_hrs", yvar = "weekly_income")
  })

}

shinyApp(ui, server)

#on the other hand, clicks work - but the values don't match. 
#The values generated by input$plot_click appear to be pixel co-ordinates.

#-----------------------------------------------------------------------------------------------

#test on dot plots?

ui <- basicPage(
  
  plotOutput("plot", brush = "plot_brush", hover = "plot_hover"),
  verbatimTextOutput("hpoint"),
  tableOutput("table")
  
)

server <- function(input, output) {
  
  output$plot <- renderPlot({
    #ggplot(income100, aes(x = weekly_income, fill = sex)) + geom_dotplot(binwidth = 50)
    ggplot(income100, aes(x = sex, y = weekly_hrs, fill = sex)) + geom_dotplot(binaxis = 'y', stackdir = 'center')
  })
  
  #output$hpoint <- renderText({
   # paste0("weekly_hrs = ", input$plot_hover$y)
  #})
  
  output$table <- renderTable({
    brushedPoints(income100, input$plot_brush, xvar = "sex", yvar = "weekly_hrs") 
    #so it doesn't seem to work if you've only got one variable.... - a bit laggy.
  })
  
}

shinyApp(ui, server)

#-----------------------------------------------------------------------------------------------

##trialling just the graph:

ui <- basicPage(
  plotOutput("plot", brush = "plot_brush")
)

server <- function(input, output) {
  output$plot <- renderPlot({
    ggplot(income100, aes(x = weekly_income, fill = sex)) + geom_dotplot(binwidth = 50)
  })
  
}

shinyApp(ui, server)

## trialling on a dotplot created by base graphics:

#creating a dotplot:

stripchart(income100$weekly_hrs, method = "stack", offset = .5, at = .15, pch = 19, 
           main = "Weekly_hrs", xlab = "weekly_hrs")

ui <- basicPage(
  plotOutput("plot", brush = "plot_brush"),
  tableOutput("table")
)

server <- function(input, output) {
  output$plot <- renderPlot({
    stripchart(income100$weekly_hrs, method = "stack", offset = 0.75, at = 0.15, pch = 19, main = "Weekly no. of hours", xlab = "weekly_hrs")
  })
  
  output$table <- renderTable({
    brushedPoints(income100, input$plot_brush, xvar = "weekly_hrs", yvar = NULL, allRows = TRUE)
  })
}

shinyApp(ui, server) #yes, so brushedPoints doesn't work on single variable dot plots. It keeps looking for a y-variable.

#What if it's a dotplot with 1 categorical + continuous?

stripchart(weekly_hrs~sex, data = income100, main = "blah", pch = 19, vertical = TRUE, col = c("red", "blue"))


ui <- basicPage(
  plotOutput("plot", brush = "plot_brush"),
  tableOutput("table")
)

server <- function(input, output) {
  output$plot <- renderPlot({
    stripchart(weekly_hrs~sex, data = income100, main = "blah", pch = 19, vertical = TRUE, col = c("red", "blue"))
  })
  
  output$table <- renderTable({
    brushedPoints(income100, input$plot_brush, xvar = "sex", yvar = "weekly_hrs")
  })
}

shinyApp(ui, server) #works!


#-----------------------------------------------------------------------------------------------

#Testing on box plots?
## for box plots? - possible. 
##Adapted example on http://shiny.rstudio.com/articles/plot-interaction-advanced.html which explains
## how to change interactivity to suit this??

ui <- basicPage(
           plotOutput("plot", click = "plot_click"),
           htmlOutput("x_value"),
           tableOutput("selected_rows")
)

server <- function(input, output) {
  output$plot <- renderPlot({
    plot(income100$sex, income100$weekly_hrs)
  })
  
  # Print the name of the x value
  output$x_value <- renderText({
    if (is.null(input$plot_click$x)) return("")
    else {
      lvls <- levels(income100$sex)
      name <- lvls[round(input$plot_click$x)]
      print(name)
    }
  })
  
  output$selected_rows <- renderTable({
    if (is.null(input$plot_click$x)) return()
    else {
      keeprows <- round(input$plot_click$x) == as.numeric(income100$sex)
      head(income100[keeprows, ], 10) 
      #can't seem to work for showing the whole dataset?
    }
  })
}


shinyApp(ui, server)

# Shiny suggests using xmin, xmax, ymin, ymax for brushing.... which might take a little longer to crack an example.

#-----------------------------------------------------------------------------------------------

#IN PROGRESS::
#Testing on bar plots?

 ggplot(data = income, aes(x = sex, y = highest_qualification)) + geom_bar() + theme_minimal()

#----------------------------------------------------------------------------------------------

#Linking different plots? - possible. https://jjallaire.shinyapps.io/shiny-ggplot2-brushing/ is an example of this.

ui <- basicPage(
  plotOutput("plot1", brush = "plot1_brush"),
  plotOutput("plot2"),
  tableOutput("table")
)

server <- function(input, output) {
  
  selected <- reactive({
    iris_brushed <- brushedPoints(iris, input$plot1_brush) 
    if (nrow(iris_brushed) == 0) {
      iris_brushed = iris }
      return(iris_brushed)
  })
  
  output$plot1 <- renderPlot({
    ggplot(iris, aes(x = Petal.Width, y = Petal.Length, color = Species)) + geom_point()
  })
  
  print(selected)
  output$plot2 <- renderPlot({
    ggplot(selected(), aes(x = Sepal.Width, y = Sepal.Length, color = Species)) + geom_point()
  })
  
  output$table <- renderTable({
    selected()
  })
}

shinyApp(ui, server)

#--------------------

#one with a bar plot:
ui <- basicPage(
  plotOutput("plot1", brush = "plot1_brush"),
  plotOutput("plot2"),
  tableOutput("table")
)

server <- function(input, output) {
  
  selected <- reactive({
    iris_brushed <<- brushedPoints(iris, input$plot1_brush) 
    if (nrow(iris_brushed) == 0) {
      iris_brushed = iris }
      return(iris_brushed)
  })
  
  output$plot1 <- renderPlot({
    ggplot(iris, aes(x = Petal.Width, y = Petal.Length, color = Species)) + geom_point()
  })
  
  output$plot2 <- renderPlot({
    ggplot(selected(), aes(x = Species, fill = Species)) + geom_bar()
  })
  
  output$table <- renderTable({
    selected()
  })

}

shinyApp(ui, server)


#---------------------
#Adding more features and interactivity?



